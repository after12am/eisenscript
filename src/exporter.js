// http://paulbourke.net/dataformats/obj/
var OBJExporter = function() {
  this.header = "# generated by [eisenscript](https://github.com/after12am/eisenscript/)\n";
  this.buff = '';
}

OBJExporter.prototype.export = function(meshes) {
  this.buff = sprintf(this.header);
  for (var i = 0; i < meshes.length; i++) {
    this.exportMesh(meshes[i], i);
  }
  return this.buff;
}

OBJExporter.prototype.exportMesh = function(mesh, i) {
  var that = this;
  var m = mesh.matrix.elements;
  
  // group
  var group = mesh.material.name + i;
  if (mesh.name) group = mesh.name;
  this.buff += sprintf("g %s\n", group);
  
  // material
  if (mesh.material.name) {
    this.buff += sprintf("usemtl %s\n", mesh.material.name);
  }
  
  // vetices
  mesh.geometry.vertices.forEach(function(v) {
    // test: v 1.0 2.0 3.0
    that.buff += sprintf(
      "v %s %s %s\n",
      m[0] * v.x + m[1] * v.y + m[2]  * v.z + m[3]  * 1,
      m[4] * v.x + m[5] * v.y + m[6]  * v.z + m[7]  * 1,
      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11] * 1
    );
  });
  
  // normals
  mesh.geometry.faces.forEach(function(face) {
    // test: vn 1.0 2.0 3.0
    that.buff += sprintf(
      "vn %s %s %s\n",
      face.normal.x,
      face.normal.y,
      face.normal.z
    );
  });
  
  // uvs
  mesh.geometry.faceVertexUvs.forEach(function(uvs) {
    // test: vt 0.1 0.2
    for (var i = 0; i < uvs.length; i++) {
      for (var j = 0; j < uvs[i].length; j++) {
        that.buff += sprintf(
          "vt %s %s\n",
          uvs[i][j].x,
          uvs[i][j].y
        );
      }
    }
  });
  
  // faces
  mesh.geometry.faces.forEach(function(face) {
    // test: f 1 2 3
    that.buff += sprintf(
      "f %s %s %s %s\n",
      face.a + 1,
      face.b + 1,
      face.c + 1,
      face.d !== undefined ? face.d + 1 : ''
    );
  });
}

OBJExporter.prototype.exportObject = function(object, i) {
  // not implemented
}